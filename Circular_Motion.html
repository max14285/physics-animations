<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 等速率圓周運動與 Delta V 演示</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #0f172a; font-family: 'Noto Sans TC', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        .ui-panel {
            background: rgba(30, 41, 59, 0.9);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(148, 163, 184, 0.2);
        }
        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        /* Custom Slider Styling */
        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #38bdf8;
            cursor: pointer;
            margin-top: -6px; 
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #475569;
            border-radius: 2px;
        }
    </style>
</head>
<body>

    <!-- Control Panel -->
    <div class="fixed top-4 left-4 w-80 ui-panel text-white p-6 rounded-xl shadow-2xl z-10">
        <h1 class="text-xl font-bold mb-4 text-sky-400 border-b border-slate-600 pb-2">等速率圓周運動分析</h1>
        
        <div class="space-y-6">
            <!-- Legend -->
            <div class="space-y-2 text-sm font-light">
                <div class="flex items-center"><span class="legend-dot bg-green-500"></span>速度向量 ($\vec{v}$)</div>
                <div class="flex items-center"><span class="legend-dot bg-red-500"></span>向心力/加速度 ($\vec{F}_c$)</div>
                <div class="flex items-center"><span class="legend-dot bg-green-500 opacity-40"></span>$\Delta t$ 後的速度 ($\vec{v}'$)</div>
                <div class="flex items-center"><span class="legend-dot bg-blue-400"></span>速度變化量 ($\Delta \vec{v}$)</div>
            </div>

            <!-- Controls -->
            <div>
                <label class="block text-sm font-medium mb-1 text-slate-300">
                    觀察時間間隔 ($\Delta t$)
                    <span id="dt-val" class="float-right text-sky-300">0.5s</span>
                </label>
                <input type="range" id="dt-slider" min="0.1" max="2.0" step="0.1" value="0.5" class="w-full">
                <p class="text-xs text-slate-400 mt-1">調整 $\Delta t$ 以觀察 $\Delta \vec{v}$ 方向的變化。當 $\Delta t$ 很小時，$\Delta \vec{v}$ 指向圓心。</p>
            </div>

            <div>
                <label class="block text-sm font-medium mb-1 text-slate-300">
                    運動速率 ($\omega$)
                </label>
                <input type="range" id="speed-slider" min="0" max="2" step="0.1" value="0.5" class="w-full">
            </div>

            <div class="flex gap-2">
                <button id="pause-btn" class="flex-1 bg-sky-600 hover:bg-sky-500 text-white py-2 rounded transition-colors font-medium">
                    暫停 / 播放
                </button>
                <button id="reset-camera" class="px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded text-slate-200 transition-colors">
                    重置視角
                </button>
            </div>
        </div>
    </div>

    <!-- Real-time Data -->
    <div class="fixed bottom-4 left-4 ui-panel text-slate-300 px-4 py-2 rounded-lg text-xs font-mono z-10 hidden sm:block">
        <p>V(x, z): <span id="debug-v"></span></p>
        <p>Pos(x, z): <span id="debug-pos"></span></p>
    </div>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

<script>
    // --- Configuration ---
    const config = {
        radius: 5,
        angularSpeed: 0.5, // rad/s
        dt: 0.5,           // seconds
        arrowScale: 2.5,   // Visual scaling for vectors
        isRunning: true
    };

    // --- State ---
    let angle = 0;
    let scene, camera, renderer, controls;
    let ball;
    let vectors = {};
    let pathLine;
    
    // --- Initialization ---
    function init() {
        const container = document.getElementById('canvas-container');

        // 1. Scene Setup
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0f172a); // Dark slate background
        scene.fog = new THREE.Fog(0x0f172a, 20, 50);

        // 2. Camera
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(10, 12, 12);
        camera.lookAt(0, 0, 0);

        // 3. Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        // 4. Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 5);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // 5. Helpers (Grid & Axes)
        const gridHelper = new THREE.GridHelper(20, 20, 0x334155, 0x1e293b);
        scene.add(gridHelper);
        
        // Center marker
        const centerGeo = new THREE.MeshBasicMaterial({ color: 0x94a3b8 });
        const centerDot = new THREE.Mesh(new THREE.SphereGeometry(0.1), centerGeo);
        scene.add(centerDot);

        // Path Circle (Orbit)
        const curve = new THREE.EllipseCurve(
            0, 0,            // ax, aY
            config.radius, config.radius, // xRadius, yRadius
            0, 2 * Math.PI,  // aStartAngle, aEndAngle
            false,           // aClockwise
            0                // aRotation
        );
        const points = curve.getPoints(100);
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const material = new THREE.LineBasicMaterial({ color: 0x475569, transparent: true, opacity: 0.5 });
        const ellipse = new THREE.Line(geometry, material);
        ellipse.rotation.x = -Math.PI / 2; // Rotate to lay flat on XZ plane
        scene.add(ellipse);

        // 6. The Physics Object (Ball)
        const ballGeo = new THREE.SphereGeometry(0.4, 32, 32);
        const ballMat = new THREE.MeshStandardMaterial({ color: 0x38bdf8, roughness: 0.4, metalness: 0.5 });
        ball = new THREE.Mesh(ballGeo, ballMat);
        ball.castShadow = true;
        scene.add(ball);

        // 7. Vector Arrows Initialization
        // Origin, Dir, Length, Color, HeadLength, HeadWidth
        
        // V1 (Current Velocity) - Green
        vectors.v1 = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,0), 1, 0x22c55e);
        vectors.v1.line.material.linewidth = 2;
        scene.add(vectors.v1);

        // V2 (Future Velocity) - Faded Green
        vectors.v2 = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,0), 1, 0x22c55e);
        // Hack to make arrow transparent
        vectors.v2.line.material.transparent = true;
        vectors.v2.line.material.opacity = 0.4;
        vectors.v2.cone.material.transparent = true;
        vectors.v2.cone.material.opacity = 0.4;
        scene.add(vectors.v2);

        // Delta V (Change in Velocity) - Blue
        // We construct this manually because ArrowHelper assumes origin is a point, but we want to draw tip-to-tip easily
        vectors.dv = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,0), 1, 0x60a5fa);
        scene.add(vectors.dv);

        // Force/Acceleration - Red
        vectors.force = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,0), 1, 0xef4444);
        scene.add(vectors.force);

        // 8. Controls
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // 9. Event Listeners
        window.addEventListener('resize', onWindowResize);
        setupUI();

        // Start Loop
        animate();
    }

    // --- UI Logic ---
    function setupUI() {
        const dtSlider = document.getElementById('dt-slider');
        const dtVal = document.getElementById('dt-val');
        const speedSlider = document.getElementById('speed-slider');
        const pauseBtn = document.getElementById('pause-btn');
        const resetBtn = document.getElementById('reset-camera');

        dtSlider.addEventListener('input', (e) => {
            config.dt = parseFloat(e.target.value);
            dtVal.innerText = config.dt + 's';
        });

        speedSlider.addEventListener('input', (e) => {
            config.angularSpeed = parseFloat(e.target.value);
        });

        pauseBtn.addEventListener('click', () => {
            config.isRunning = !config.isRunning;
        });

        resetBtn.addEventListener('click', () => {
            camera.position.set(10, 12, 12);
            camera.lookAt(0, 0, 0);
            controls.reset();
        });
    }

    // --- Physics Calculation ---
    function updatePhysics() {
        // 1. Update Main Ball Position
        if (config.isRunning) {
            angle += config.angularSpeed * 0.016; // Approx 60fps step
        }
        
        const R = config.radius;
        // Position: (R*cos(theta), 0, R*sin(theta)) - Standard Parametric Circle
        // Note: Three.js uses (x, y, z). We orbit on X-Z plane, Y is up.
        const x = R * Math.cos(angle);
        const z = R * Math.sin(angle);
        
        ball.position.set(x, 0, z);

        // 2. Calculate Vectors (Math)
        
        // Current Velocity Direction: Tangent to circle (-sin, cos)
        const v1Dir = new THREE.Vector3(-Math.sin(angle), 0, Math.cos(angle)).normalize();
        
        // Future Velocity Direction (at t + dt)
        // Future Angle = angle + angularVelocity * dt
        const futureAngle = angle + (config.angularSpeed * config.dt);
        const v2Dir = new THREE.Vector3(-Math.sin(futureAngle), 0, Math.cos(futureAngle)).normalize();

        // Centripetal Force Direction: Towards center (opposite to position vector)
        const forceDir = new THREE.Vector3(-Math.cos(angle), 0, -Math.sin(angle)).normalize();

        // 3. Update Visuals (ArrowHelpers)
        
        const vectorLen = 3; // Standard visual length for V vectors

        // Update V1 (Green) - Attached to ball
        vectors.v1.position.copy(ball.position);
        vectors.v1.setDirection(v1Dir);
        vectors.v1.setLength(vectorLen, 0.5, 0.3);

        // Update Force (Red) - Attached to ball
        vectors.force.position.copy(ball.position);
        vectors.force.setDirection(forceDir);
        vectors.force.setLength(2, 0.5, 0.3); // Force vector slightly shorter

        // Update V2 (Faded Green) - Also attached to ball to show comparison at same origin
        // This represents: "If we draw V(t) and V(t+dt) starting from the same point..."
        vectors.v2.position.copy(ball.position);
        vectors.v2.setDirection(v2Dir);
        vectors.v2.setLength(vectorLen, 0.5, 0.3);

        // Update Delta V (Blue)
        // Delta V = V2 - V1.
        // Visually: Connects tip of V1 to tip of V2.
        
        // Tip of V1 position relative to world
        const v1Tip = v1Dir.clone().multiplyScalar(vectorLen).add(ball.position);
        
        // Tip of V2 position relative to world
        const v2Tip = v2Dir.clone().multiplyScalar(vectorLen).add(ball.position);

        // Direction from V1 tip to V2 tip
        const dvVector = new THREE.Vector3().subVectors(v2Tip, v1Tip);
        const dvLen = dvVector.length();
        const dvDir = dvVector.clone().normalize();

        // Position the Delta V arrow at the tip of V1
        vectors.dv.position.copy(v1Tip);
        vectors.dv.setDirection(dvDir);
        
        // If dt is very small, dvLen approaches 0, avoid warning
        if (dvLen > 0.01) {
            vectors.dv.setLength(dvLen, 0.4, 0.2);
            vectors.dv.visible = true;
        } else {
            vectors.dv.visible = false;
        }

        // Debug Text
        document.getElementById('debug-v').innerText = `${v1Dir.x.toFixed(2)}, ${v1Dir.z.toFixed(2)}`;
        document.getElementById('debug-pos').innerText = `${x.toFixed(2)}, ${z.toFixed(2)}`;
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        updatePhysics();
        controls.update();
        renderer.render(scene, camera);
    }

    // Boot
    init();

</script>
</body>
</html>
