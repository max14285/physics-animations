<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D ç°¡è«§é‹å‹•æ¨¡æ“¬ (å®šå¯¬å‘é‡ç‰ˆ)</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #121212;
            color: #f0f0f0;
            margin: 0;
            overflow: hidden;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        #error-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff4444;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 8px;
            display: none;
            z-index: 100;
            text-align: center;
            border: 1px solid #ff4444;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00d2ff;
            font-size: 1.2rem;
            z-index: 50;
            pointer-events: none;
        }

        .ui-overlay {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(30, 30, 30, 0.9);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            width: 320px;
            z-index: 10;
            backdrop-filter: blur(5px);
            border: 1px solid #444;
        }

        h2 { margin: 0 0 15px 0; font-weight: 300; font-size: 1.2rem; text-align: center; color: #fff; }

        .sliders { display: flex; flex-direction: column; gap: 15px; }

        .control-group {
            background: rgba(60, 60, 60, 0.5);
            padding: 10px 15px;
            border-radius: 8px;
        }

        .checkboxes {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(60, 60, 60, 0.5);
            border-radius: 8px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            user-select: none;
            font-size: 0.9rem;
        }

        input[type=range] { width: 100%; cursor: pointer; }
        .value-display { float: right; color: #4CAF50; font-weight: bold; }
        .vec-legend { width: 10px; height: 10px; border-radius: 2px; display: inline-block; }
        
        .instructions {
            margin-top: 15px;
            font-size: 0.8rem;
            color: #aaa;
            text-align: center;
            border-top: 1px solid #555;
            padding-top: 10px;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loading">æ­£åœ¨è¼‰å…¥ 3D å¼•æ“...</div>
    <div id="error-msg"></div>
    <div id="canvas-container"></div>

    <div class="ui-overlay">
        <h2>3D é‰›ç›´åœ“å‘¨æŠ•å½±æ¨¡æ“¬</h2>
        
        <div class="checkboxes">
            <label class="checkbox-item">
                <input type="checkbox" id="checkVel" checked> 
                <span class="vec-legend" style="background:#00ff00;"></span> é€Ÿåº¦ (v)
            </label>
            <label class="checkbox-item">
                <input type="checkbox" id="checkAcc" checked> 
                <span class="vec-legend" style="background:#ff9800;"></span> åŠ é€Ÿåº¦ (a)
            </label>
            <label class="checkbox-item">
                <input type="checkbox" id="checkForce"> 
                <span class="vec-legend" style="background:#d500f9;"></span> å—åŠ› (F)
            </label>
        </div>

        <div class="sliders">
            <div class="control-group">
                <label>
                    ç‰©ç†è³ªé‡ (m) <span id="massVal" class="value-display">2.0 kg</span>
                </label>
                <input type="range" id="massSlider" min="0.5" max="10" step="0.5" value="2.0">
            </div>

            <div class="control-group">
                <label>
                    å½ˆæ€§å¸¸æ•¸ (k) <span id="kVal" class="value-display">2.0 N/m</span>
                </label>
                <input type="range" id="kSlider" min="0.5" max="10" step="0.5" value="2.0">
            </div>
        </div>
        
        <div style="margin-top: 10px; font-size: 0.9em; color: #ccc; text-align: center;">
            è§’é »ç‡ $\omega$ = <span id="omegaVal" style="color:white">1.00</span> rad/s
        </div>

        <div class="instructions">
            <p>ğŸ–±ï¸ æ»‘é¼ æ“ä½œè¦–è§’ï¼š</p>
            <p>å·¦éµæ—‹è½‰ | å³éµå¹³ç§» | æ»¾è¼ªç¸®æ”¾</p>
        </div>
    </div>

    <script>
        window.onerror = function(message) {
            const errDiv = document.getElementById('error-msg');
            errDiv.style.display = 'block';
            errDiv.innerHTML = `<strong>éŒ¯èª¤ï¼š</strong><br>${message}<br><br>è«‹æª¢æŸ¥ç¶²è·¯é€£ç·šã€‚`;
            document.getElementById('loading').style.display = 'none';
        };
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- UI Elements ---
        const massSlider = document.getElementById('massSlider');
        const kSlider = document.getElementById('kSlider');
        const checkVel = document.getElementById('checkVel');
        const checkAcc = document.getElementById('checkAcc');
        const checkForce = document.getElementById('checkForce');
        const massDisplay = document.getElementById('massVal');
        const kDisplay = document.getElementById('kVal');
        const omegaDisplay = document.getElementById('omegaVal');
        const loadingDiv = document.getElementById('loading');

        // --- Physics State ---
        let time = 0;
        let mass = parseFloat(massSlider.value);
        let k = parseFloat(kSlider.value);
        let omega = Math.sqrt(k / mass);
        const amplitude = 150; 
        
        // --- Vector Scaling ---
        const V_SCALE = 35; 
        const A_SCALE = 80; 
        const F_SCALE = 30;

        // --- Three.js Globals ---
        let scene, camera, renderer, controls;
        let circleSphere, shmSphere;
        let springLine, projectionLine;
        // Arrows
        let arrowVelC, arrowAccC, arrowForceC;
        let arrowVelS, arrowAccS, arrowForceS;
        // Labels
        let labelVelC, labelAccC, labelForceC;
        let labelVelS, labelAccS, labelForceS;

        // Layout Constants
        const circleCenterY = 200; 
        const floorY = -50;        
        const wallX = -amplitude - 120;

        try {
            init();
            loadingDiv.style.display = 'none';
            animate();
        } catch (e) {
            console.error(e);
            document.getElementById('error-msg').style.display = 'block';
            document.getElementById('error-msg').innerHTML = "åˆå§‹åŒ–å¤±æ•—ï¼š" + e.message;
        }

        // Helper to create text texture
        function createTextTexture(text, color) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.font = 'Bold 64px Arial'; 
            const textWidth = ctx.measureText(text).width;
            canvas.width = textWidth + 20;
            canvas.height = 80;
            
            ctx.font = 'Bold 64px Arial';
            ctx.fillStyle = color;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, canvas.width/2, canvas.height/2);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            return texture;
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);
            scene.fog = new THREE.Fog(0x222222, 500, 2500);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 5000);
            camera.position.set(0, 150, 700); 

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            const mainLight = new THREE.DirectionalLight(0xffffff, 1);
            mainLight.position.set(100, 300, 200);
            mainLight.castShadow = true;
            scene.add(mainLight);

            // Environment
            const floorGeo = new THREE.PlaneGeometry(2000, 1000);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8, metalness: 0.2 });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = floorY - 20;
            floor.receiveShadow = true;
            scene.add(floor);

            const wallGeo = new THREE.BoxGeometry(20, 350, 200);
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
            const wall = new THREE.Mesh(wallGeo, wallMat);
            wall.position.set(wallX - 10, floorY + 120, 0);
            wall.castShadow = true;
            wall.receiveShadow = true;
            scene.add(wall);

            const trackGeo = new THREE.TorusGeometry(amplitude, 2, 16, 100);
            const trackMat = new THREE.MeshBasicMaterial({ color: 0x666666, transparent: true, opacity: 0.5 });
            const track = new THREE.Mesh(trackGeo, trackMat);
            track.position.y = circleCenterY;
            scene.add(track);

            const postMat = new THREE.MeshBasicMaterial({ color: 0x555555 });
            const axisPost = new THREE.Mesh(new THREE.CylinderGeometry(2, 2, 50), postMat);
            axisPost.rotation.x = Math.PI / 2;
            axisPost.position.y = circleCenterY;
            scene.add(axisPost);
            const supportPost = new THREE.Mesh(new THREE.CylinderGeometry(3, 3, circleCenterY - floorY), postMat);
            supportPost.position.set(0, (circleCenterY + floorY)/2, -20);
            scene.add(supportPost);

            // Balls
            const ballGeo = new THREE.SphereGeometry(1, 32, 32); 
            const circleMat = new THREE.MeshPhongMaterial({ color: 0x00d2ff, shininess: 100 });
            circleSphere = new THREE.Mesh(ballGeo, circleMat);
            circleSphere.castShadow = true;
            scene.add(circleSphere);
            const shmMat = new THREE.MeshPhongMaterial({ color: 0xff4081, shininess: 100 });
            shmSphere = new THREE.Mesh(ballGeo, shmMat);
            shmSphere.castShadow = true;
            scene.add(shmSphere);

            // Lines
            const projectionGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,1,0)]);
            const projectionMat = new THREE.LineDashedMaterial({ color: 0xffffff, dashSize: 10, gapSize: 10, opacity: 0.4, transparent: true });
            projectionLine = new THREE.Line(projectionGeo, projectionMat);
            scene.add(projectionLine);
            const springGeo = new THREE.BufferGeometry().setFromPoints(new Array(100).fill(new THREE.Vector3(0,0,0)));
            const springMat = new THREE.LineBasicMaterial({ color: 0xaaaaaa });
            springLine = new THREE.Line(springGeo, springMat);
            scene.add(springLine);

            // Arrows & Labels
            const origin = new THREE.Vector3(0, 0, 0);
            const dir = new THREE.Vector3(1, 0, 0);
            const createArrow = (color) => new THREE.ArrowHelper(dir, origin, 1, color);
            
            const createLabel = (text, color) => {
                const texture = createTextTexture(text, color);
                const material = new THREE.SpriteMaterial({ map: texture, depthTest: false });
                const sprite = new THREE.Sprite(material);
                sprite.scale.set(30, 15, 1); 
                sprite.renderOrder = 999; 
                return sprite;
            };

            arrowVelC = createArrow(0x00ff00); scene.add(arrowVelC);
            arrowAccC = createArrow(0xff9800); scene.add(arrowAccC);
            arrowForceC = createArrow(0xd500f9); scene.add(arrowForceC);
            arrowVelS = createArrow(0x00ff00); scene.add(arrowVelS);
            arrowAccS = createArrow(0xff9800); scene.add(arrowAccS);
            arrowForceS = createArrow(0xd500f9); scene.add(arrowForceS);

            labelVelC = createLabel("v", "#00ff00"); scene.add(labelVelC);
            labelAccC = createLabel("a", "#ff9800"); scene.add(labelAccC);
            labelForceC = createLabel("F", "#d500f9"); scene.add(labelForceC);
            labelVelS = createLabel("v", "#00ff00"); scene.add(labelVelS);
            labelAccS = createLabel("a", "#ff9800"); scene.add(labelAccS);
            labelForceS = createLabel("F", "#d500f9"); scene.add(labelForceS);

            window.addEventListener('resize', onWindowResize);
            updateParams();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateParams() {
            mass = parseFloat(massSlider.value);
            k = parseFloat(kSlider.value);
            omega = Math.sqrt(k / mass);
            
            massDisplay.textContent = mass.toFixed(1) + " kg";
            kDisplay.textContent = k.toFixed(1) + " N/m";
            omegaDisplay.textContent = omega.toFixed(2);

            const ballScale = 15 + (Math.pow(mass, 1/3) * 6);
            circleSphere.scale.set(ballScale, ballScale, ballScale);
            shmSphere.scale.set(ballScale, ballScale, ballScale);
        }

        [massSlider, kSlider].forEach(el => el.addEventListener('input', updateParams));

        function animate() {
            requestAnimationFrame(animate);
            const delta = 0.03;
            time += delta;

            let cosT = Math.cos(time * omega);
            let sinT = Math.sin(time * omega);
            let x = amplitude * cosT;
            let y_circle_local = amplitude * sinT;

            // Update Positions
            circleSphere.position.set(x, circleCenterY + y_circle_local, 0);
            shmSphere.position.set(x, floorY, 0);

            // Update Lines
            const positions = projectionLine.geometry.attributes.position.array;
            positions[0] = circleSphere.position.x; positions[1] = circleSphere.position.y; positions[2] = circleSphere.position.z;
            positions[3] = shmSphere.position.x; positions[4] = shmSphere.position.y; positions[5] = shmSphere.position.z;
            projectionLine.geometry.attributes.position.needsUpdate = true;
            projectionLine.computeLineDistances();

            updateSpringGeometry(springLine.geometry, wallX, floorY, 0, shmSphere.position.x, floorY, 0);

            // Vector Math
            let v_mag = amplitude * omega;
            let vx_c = -v_mag * sinT; let vy_c = v_mag * cosT;
            
            let a_mag = amplitude * omega * omega;
            let ax_c = -a_mag * cosT; let ay_c = -a_mag * sinT;

            let fx_c = mass * ax_c; let fy_c = mass * ay_c;

            const showV = checkVel.checked;
            const showA = checkAcc.checked;
            const showF = checkForce.checked;

            function updateArrow(arrow, label, pos, dirVec, scale, isVisible, offsetY = 0) {
                arrow.visible = isVisible;
                label.visible = isVisible;
                if (!isVisible) return;
                
                const len = dirVec.length();
                if (len < 0.001) { arrow.setLength(0); label.visible = false; return; }
                
                const normalizedDir = dirVec.clone().normalize();
                arrow.position.copy(pos);
                arrow.position.y += offsetY;
                arrow.setDirection(normalizedDir);
                
                const arrowTotalLen = len * (scale/amplitude) + 1;
                
                // --- é—œéµä¿®æ”¹ï¼šå›ºå®šç®­é ­é ­éƒ¨çš„é•·åº¦èˆ‡å¯¬åº¦ ---
                // setLength(totalLength, headLength, headWidth)
                // é€™è£¡è¨­å®š headLength = 20 (å›ºå®š), headWidth = 10 (å›ºå®š)
                arrow.setLength(arrowTotalLen, 20, 10); 

                // Position Label at tip
                const tipPos = arrow.position.clone().add(normalizedDir.multiplyScalar(arrowTotalLen));
                label.position.copy(tipPos).add(new THREE.Vector3(10, 10, 0));
            }

            // Circle Vectors
            updateArrow(arrowVelC, labelVelC, circleSphere.position, new THREE.Vector3(vx_c, vy_c, 0), V_SCALE, showV);
            updateArrow(arrowAccC, labelAccC, circleSphere.position, new THREE.Vector3(ax_c, ay_c, 0), A_SCALE, showA);
            updateArrow(arrowForceC, labelForceC, circleSphere.position, new THREE.Vector3(fx_c, fy_c, 0), F_SCALE, showF, 0);

            // SHM Vectors
            updateArrow(arrowVelS, labelVelS, shmSphere.position, new THREE.Vector3(vx_c, 0, 0), V_SCALE, showV, 25);
            updateArrow(arrowAccS, labelAccS, shmSphere.position, new THREE.Vector3(ax_c, 0, 0), A_SCALE, showA, 45);
            updateArrow(arrowForceS, labelForceS, shmSphere.position, new THREE.Vector3(fx_c, 0, 0), F_SCALE, showF, -25);

            controls.update();
            renderer.render(scene, camera);
        }

        function updateSpringGeometry(geometry, x1, y1, z1, x2, y2, z2) {
            const positions = geometry.attributes.position.array;
            const pointCount = positions.length / 3;
            const windings = 12;
            const radius = 15;
            const start = new THREE.Vector3(x1, y1, z1);
            const end = new THREE.Vector3(x2 - 15, y2, z2);
            const diff = new THREE.Vector3().subVectors(end, start);
            const length = diff.length();
            const axis = diff.clone().normalize();
            for (let i = 0; i < pointCount; i++) {
                const t = i / (pointCount - 1);
                const pos = start.clone().add(axis.clone().multiplyScalar(t * length));
                if (t > 0.05 && t < 0.95) {
                    const spiralT = (t - 0.05) / 0.9;
                    const spiralAngle = spiralT * windings * Math.PI * 2;
                    pos.y += Math.cos(spiralAngle) * radius;
                    pos.z += Math.sin(spiralAngle) * radius;
                }
                positions[i * 3] = pos.x; positions[i * 3 + 1] = pos.y; positions[i * 3 + 2] = pos.z;
            }
            geometry.attributes.position.needsUpdate = true;
        }
    </script>
</body>
</html>
